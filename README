Allocation Utilities
====================
This is a C library containing several utilities for dealing with dynamic
memory allocation. It contains:

  - Fixed Size Allocator
  - Byte Builder
  - Fixed Size Builder
  - Variable Size Builder

Fixed Size Allocators (FSA)
===========================
The builders (mentioned later) don't deal with fragmentation of the address
space they're using. A fixed size allocator does.

A fixed size allocator doesn't allow for heterogeneous sized allocations. All
allocations have to be of the same size. What distinguises a FSA from the
others is that *any* allocated block can be freed. Not just the last N bytes,
or just last N blocks, or only the whole thing at once.

Builders
========
There are cases in which you want to build something which you're not aware of
the size. For example, imagine you're reading a file and you want to build a
sequence of lines. Some files can have extremely large lines (imagine an html
source file, or a minified JS source file), while in others lines are pretty
much bounded to a fixed upper limit (this file for example). It'd be
interesting if you could use something like fgets to read as much N chars and
incrementally build the line:

  LineBuilder l;
  char buf[80];
  setup l
  open l for append
  do {
    read with fgets into buf;
    append buf into l
  } while (not end of line);
  close l
  char *line = chars(l);
  ...
  ...
  ...
  free(l);

That's the idea behind builder types.

There are byte builders and fixed size builders. Given a builder, basically
these are the operations you can do to it:

  - Setup
  - Append
  - AppendForSetup
  - GetMemory
  - DiscardAppends

Once you set asside some memory for the builder (a local variable for example),
you have to call Setup on it.

After setting up a builder, it's  appendable. Now you can make append calls
copy elements into it. There are two kinds of append calls. A simple Append
call will take some bytes and copy them into the underlying builder storage.
However, in some cases, you'll need to do your own setup on the underlying
memory (a simple copy won't do). In such cases, call AppendForSetup. Such call
will return you the underlying store for the appended element(s) so you can do
your own setup on them.

The thing to be cautious about with AppendForSetup is that at each append, the
base address of the underlying memory for the builder may change (very much
like with calls to realloc), and you should take that into account while coding
your own programs using builder types.

  - Append: get some elements, copy them into the underlying store, expanding
  it if needed.
  - AppendForSetup: get a size value, adjust the underlying store to fit the
  given amount of bytes, expanding if needed, and return the underlying store
  so you can work on it. No copy is done.

Once you're done appending elements, you can confidently get the underlying
memory and use however you'd like. To do so, make a GetMemory call. You can
still make append calls after getting the underlying memory. This is useful if
you want to increment the build later. All you need to remember is that the
address you had for the base address can be invalidated at each append call,
which means you'll have to call GetMemory again at each "append session".

The builder won't free the underlying memory for you. You're the one
responsible for calling free on the underlying memory. After you're fully done
with appends you can actually get rid of the builder and only keep the
underlying base address.

You can also recycle the builder. There are two ways you can do that.

The first way is by a call to DiscardAppends. This will tell the builder that
its underlying base memory is now unused. Calls to append from now on will
reuse all the space previously allocated for the older appends.

Another way is by simply getting the underlying base pointer and store it
somewhere else and calling setup on the buffer again. A call to setup will
assume the builder fields are uninitialized and will give you a fresh setup for
the builder without interfering with the older underlying memory.

This library makes no attempt to make bounded builders. There are though:

  - Byte Builders
  - Fixed Size Builders
  - Variable Size Builders

For byte builders and fixed size builders, there is a special 'discard appends'
call which discards only the last N entries.

Variable Size Builders
======================
Variable size builders are considerably different from the other builder
types that I think it deserves some attention.

The difference between a byte builder and a variable size builder is mostly
that a VSB will make conservative alignment assumptions, while byte builders
will do byte alignment. This makes a VSB a poor choice for small elements in
terms of memory consumption. For example, if VSB uses 16 byte alignment, and
you need to add a bunch of shorts, ints and longs to it, you'd be using at
most half the memory, assuming longs are 8 bytes. A VSB is a better choice for
when you have larger objects.

One case for using VSB could be that you have to build a structure which puts
together time (struct tm) objects, and texts based off what you read from your
input source:

  - You would need space for struct tm objects.
  - You would need space for text strings.
  - You would need space for the struct binding the date/text pair.

This could be a good situation to use a VSB. However, VSB don't work well with
incrementally building text. If you plan to incrementally build strings using a
VSB, you're out of luck because your strings will almost certainly have gaps
(possibly containing a zero byte in there) between them. This is because of the
conservative alignment assumptions VSB has to work with.

So the example above is only reliable if you can avoid incrementally building
the string.

The alignment choices made by VSB are hardcoded internally in the library. If
you want different alignment options, you would need to build your own builder
on top of a byte builder.

The thing to remember about VSB is how consecutive appends may leave gaps in
the underlying memory block. The gaps are pretty small if you have large
structs, but they can still be significant in other cases.

The computation of which is the alignment size to be used is done by looking
at sizes of fundamental types in the language:

  union AlignmentType {
    int i;
    long l;
    long long ll;
    void *vp;
    void (*funp)(void);
    float f;
    double d;
    long double ld;
    float *fp;
    double *dp;
    long double *ldp;
  };

  enum {
    ALIGNMENT_BOUNDARY = sizeof (union AlignmentType)
  };

Although this code isn't part of the header, it's something like this that is
used internally by the library to figure out the alignment boundary a VSB will
use. This idea came from the "C Interfaces and Implementations" book, which
suggest something similar.

Byte Allocators
===============
There are allocators above that operate on a byte level, like a byte stack
allocator. These allocators aren't meant to be general purpose memory
allocators (although you can make them be so if you're willing to go through
the effort). Their intended usage is for byte strings.

Since they operate on a byte level, they don't worry about alignment issues
narely as much as the other kinds of allocators.

Malloc Configuration and Errors
===============================
You can configure which malloc/free/calloc/realloc to use in the XMalloc.h
file.

!!! TALK ABOUT ERRORS !!!

Names
=====
All names are prefixed with AU (allocation utilities). Names for operations on
particular kinds of allocators have yet another prefix.

  AU_FSA_Setup
  AU_FSA_Alloc
  AU_FSA_Free
  AU_FSA_Destroy

  AU_B1_Setup
  AU_B1_Append
  AU_B1_AppendForSetup
  AU_B1_GetMemory
  AU_B1_DiscardAppends
  AU_B1_DiscardLastBytes

  AU_VSB_Setup
  AU_VSB_Append
  AU_VSB_AppendForSetup
  AU_VSB_GetMemory
  AU_VSB_DiscardAppends

  AU_FSB_Setup
  AU_FSB_Append
  AU_FSB_AppendForSetup
  AU_FSB_GetMemory
  AU_FSB_DiscardAppends
  AU_FSB_DiscardLastAppends

A difference between bounded allocators and unbounded ones surfaces here. There
aren't procedures to destroy a bounded allocator. This is because a bounded
allocator will operate entirely within its given memory. On its own, this is
enough for not needing a destruction procedure here.

To be clear, procedures 'free' release memory that is managed by the allocator.
Procedures 'destroy' destroy the allocator. If you've allocated the allocator
with a call to malloc on your own then you should of course free it yourself.
The allocator destroy functions will only release memory they allocated
themselves.

Opaqueness
==========
Allocatores aren't opaque types strictly speaking. You *do* have access to the
struct declaration. However, you're not supposed to access the fields diretly.
Every allocator manipulation should be done through a function call or macro
application.

The reason why the types aren't fully opaque types is just so you can declare
variables of allocator types with automatic and also with static storage
duration.

This is the reason why the types aren't accessible directly as struct tags, and
are only so indirectly through typedefs.

Thread Safety and Reentrancy
============================
If the provided malloc/free/calloc/realloc aren't thread safe, two concurrent
AU_* calls won't be data race free. However, if thread safety is provided in
the underlying malloc/.../ralloc functions, then you can call this library's
functions on different instances (which is what would be intuitively expected
in my opinion).

Reentrancy only depends on the reentrancy of the provided allocation functions.

Errors Values
=============
Throughout the library, functions which can error return negative values on
error conditions and 0 on success.

Debug Options
=============
On debug mode (NDEBUG isn't defined), several assertions will be turned on.
They will check for:

  - null parameters
  - overflow

When they're turned off, several properties will just be assumed to be true.
For example, that you won't pass null parameters or that you won't pass two
numbers that need to be multiplied and will overflow if done so.

Some sizes are outside of your control, so you can't and won't be held
responsible for checking overflow on those values. For example, when appending
bytes on a byte builder, you don't have access to the underlying capacity. So
you don't know if adding it to the size for a next append will overflow or
not. Thus, in this case (and others like it), the library will return an error
code.
